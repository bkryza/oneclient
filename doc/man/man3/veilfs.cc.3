.TH "src/fuse/veilfs.cc" 3 "Wed Jul 31 2013" "VeilClient" \" -*- nroff -*-
.ad l
.nh
.SH NAME
src/fuse/veilfs.cc \- 
.SH SYNOPSIS
.br
.PP
.SS "Macros"

.in +1c
.ti -1c
.RI "#define \fBSH_RUN\fP(NAME, ARGS, FUN)"
.br
.RI "\fIRuns FUN on NAME storage helper with constructed with ARGS\&. Return value is avaiable in 'int sh_return'\&. \fP"
.ti -1c
.RI "#define \fBRETURN_IF_ERROR\fP(X)"
.br
.RI "\fIIf given veilError does not produce POSIX 0 return code, interrupt execution by returning POSIX error code\&. \fP"
.ti -1c
.RI "#define \fBGET_LOCATION_INFO\fP(PATH)"
.br
.RI "\fIFetch \fBlocationInfo\fP and \fBstorageInfo\fP for given file\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
\fBAuthor:\fP
.RS 4
Rafal Slota 
.RE
.PP
\fBCopyright:\fP
.RS 4
(C) 2013 ACK CYFRONET AGH 
.PP
This software is released under the MIT license cited in 'LICENSE\&.txt' 
.RE
.PP

.SH "Macro Definition Documentation"
.PP 
.SS "#define GET_LOCATION_INFO(PATH)"
\fBValue:\fP
.PP
.nf
locationInfo lInfo; \\
                                storageInfo sInfo; \
                                try \
                                { \
                                    pair<locationInfo, storageInfo> tmpLoc = m_storageMapper->getLocationInfo(string(PATH), true); \
                                    lInfo = tmpLoc\&.first; \
                                    sInfo = tmpLoc\&.second; \
                                } \
                                catch(VeilException e) \
                                { \
                                    LOG(WARNING) << 'cannot get file mapping for file: ' << string(PATH) << ' (error: ' << e\&.what() << ')'; \
                                    return VeilFS::translateError(e\&.veilError()); \
                                }
.fi
.PP
Fetch \fBlocationInfo\fP and \fBstorageInfo\fP for given file\&. On success - lInfo and sInfo variables will be set\&. On error - POSIX error code will be returned, interrupting code execution\&. 
.SS "#define RETURN_IF_ERROR(X)"
\fBValue:\fP
.PP
.nf
{ \
                                int err = VeilFS::translateError(X); \
                                if(err != 0) return err; \
                            }
.fi
.PP
If given veilError does not produce POSIX 0 return code, interrupt execution by returning POSIX error code\&. 
.SS "#define SH_RUN(NAME, ARGS, FUN)"
\fBValue:\fP
.PP
.nf
IStorageHelper *ptr = StorageHelperFactory::instance()->getStorageHelper(NAME, ARGS); \
                                if(ptr == NULL) { LOG(ERROR) << 'storage helper '' << NAME << '' not found'; return -EIO; } \
                                int sh_return = ptr->FUN; \
                                delete ptr;
.fi
.PP
Runs FUN on NAME storage helper with constructed with ARGS\&. Return value is avaiable in 'int sh_return'\&. 
.SH "Author"
.PP 
Generated automatically by Doxygen for VeilClient from the source code\&.
