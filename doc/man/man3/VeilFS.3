.TH "VeilFS" 3 "Wed Jul 31 2013" "VeilClient" \" -*- nroff -*-
.ad l
.nh
.SH NAME
VeilFS \- 
.PP
The \fBVeilFS\fP main class\&.  

.SH SYNOPSIS
.br
.PP
.SS "Public Member Functions"

.in +1c
.ti -1c
.RI "\fB~VeilFS\fP ()"
.br
.ti -1c
.RI "void \fBset_rootdir\fP (const char *path)"
.br
.RI "\fISets root dir for \fBVeilFS\fP\&. \fP"
.ti -1c
.RI "int \fBaccess\fP (const char *path, int mask)"
.br
.RI "\fI\fIaccess\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBgetattr\fP (const char *path, struct stat *statbuf)"
.br
.RI "\fI\fIgetattr\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBreadlink\fP (const char *path, char *\fBlink\fP, size_t size)"
.br
.RI "\fI\fIreadlink\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBmknod\fP (const char *path, mode_t mode, dev_t dev)"
.br
.RI "\fI\fImknod\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBmkdir\fP (const char *path, mode_t mode)"
.br
.RI "\fImkdir FUSE callback\&. \fP"
.ti -1c
.RI "int \fBunlink\fP (const char *path)"
.br
.RI "\fI\fIunlink\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBrmdir\fP (const char *path)"
.br
.RI "\fI\fIrmdir\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBsymlink\fP (const char *path, const char *\fBlink\fP)"
.br
.RI "\fI\fIsymlink\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBrename\fP (const char *path, const char *newpath)"
.br
.RI "\fI\fIrename\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBlink\fP (const char *path, const char *newpath)"
.br
.RI "\fI\fIlink\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBchmod\fP (const char *path, mode_t mode)"
.br
.RI "\fI\fIchmod\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBchown\fP (const char *path, uid_t uid, gid_t gid)"
.br
.RI "\fI\fIchown\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBtruncate\fP (const char *path, off_t newSize)"
.br
.RI "\fI\fItruncate\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fButime\fP (const char *path, struct utimbuf *ubuf)"
.br
.RI "\fI\fIutime\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBopen\fP (const char *path, struct fuse_file_info *fileInfo)"
.br
.RI "\fI\fIopen\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBread\fP (const char *path, char *buf, size_t size, off_t offset, struct fuse_file_info *fileInfo)"
.br
.RI "\fI\fIread\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBwrite\fP (const char *path, const char *buf, size_t size, off_t offset, struct fuse_file_info *fileInfo)"
.br
.RI "\fI\fIwrite\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBstatfs\fP (const char *path, struct statvfs *statInfo)"
.br
.RI "\fI\fIstatfs\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBflush\fP (const char *path, struct fuse_file_info *fileInfo)"
.br
.RI "\fI\fIflush\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBrelease\fP (const char *path, struct fuse_file_info *fileInfo)"
.br
.RI "\fI\fIrelease\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBfsync\fP (const char *path, int datasync, struct fuse_file_info *fi)"
.br
.RI "\fI\fIfsync\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBsetxattr\fP (const char *path, const char *name, const char *value, size_t size, int flags)"
.br
.RI "\fI\fIsetxattr\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBgetxattr\fP (const char *path, const char *name, char *value, size_t size)"
.br
.RI "\fI\fIgetxattr\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBlistxattr\fP (const char *path, char *list, size_t size)"
.br
.RI "\fI\fIlistxattr\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBremovexattr\fP (const char *path, const char *name)"
.br
.RI "\fI\fIremovexattr\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBopendir\fP (const char *path, struct fuse_file_info *fileInfo)"
.br
.RI "\fI\fIopendir\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBreaddir\fP (const char *path, void *buf, fuse_fill_dir_t filler, off_t offset, struct fuse_file_info *fileInfo)"
.br
.RI "\fI\fIreaddir\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBreleasedir\fP (const char *path, struct fuse_file_info *fileInfo)"
.br
.RI "\fI\fIreleasedir\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBfsyncdir\fP (const char *path, int datasync, struct fuse_file_info *fileInfo)"
.br
.RI "\fI\fIfsyncdir\fP FUSE callback\&. \fP"
.ti -1c
.RI "int \fBinit\fP (struct fuse_conn_info *conn)"
.br
.RI "\fI\fIinit\fP FUSE callback\&. \fP"
.in -1c
.SS "Static Public Member Functions"

.in +1c
.ti -1c
.RI "static \fBVeilFS\fP * \fBinstance\fP ()"
.br
.RI "\fIReturns instance of \fBVeilFS\fP singleton\&. \fP"
.ti -1c
.RI "static int \fBtranslateError\fP (string verr)"
.br
.RI "\fIerrno translator\&. \fP"
.ti -1c
.RI "static \fBJobScheduler\fP * \fBgetScheduler\fP ()"
.br
.RI "\fIReturns \fBJobScheduler\fP assigned to this object\&. \fP"
.in -1c
.SS "Private Member Functions"

.in +1c
.ti -1c
.RI "\fBVeilFS\fP ()"
.br
.RI "\fIPrivate constuctor (\fBVeilFS\fP is a singleton) \fP"
.in -1c
.SS "Private Attributes"

.in +1c
.ti -1c
.RI "const char * \fBm_root\fP"
.br
.RI "\fIFilesystem root directory\&. \fP"
.ti -1c
.RI "\fBFslogicProxy\fP * \fBm_fslogic\fP"
.br
.RI "\fI\fBFslogicProxy\fP instance\&. \fP"
.ti -1c
.RI "\fBStorageMapper\fP * \fBm_storageMapper\fP"
.br
.RI "\fI\fBStorageMapper\fP instance\&. \fP"
.ti -1c
.RI "\fBJobScheduler\fP * \fBm_jobScheduler\fP"
.br
.RI "\fI\fBJobScheduler\fP instance\&. \fP"
.ti -1c
.RI "\fBMetaCache\fP * \fBm_metaCache\fP"
.br
.RI "\fI\fBMetaCache\fP instance\&. \fP"
.in -1c
.SS "Static Private Attributes"

.in +1c
.ti -1c
.RI "static \fBVeilFS\fP * \fBm_instance\fP = NULL"
.br
.RI "\fIClass instance\&. \fP"
.in -1c
.SH "Detailed Description"
.PP 
The \fBVeilFS\fP main class\&. 

This class contains FUSE all callbacks, so it basically is an heart of the filesystem\&. Technically \fBVeilFS\fP is an singleton created on programm start and registred in FUSE daemon\&. 
.SH "Constructor & Destructor Documentation"
.PP 
.SS "VeilFS::VeilFS ()\fC [private]\fP"

.PP
Private constuctor (\fBVeilFS\fP is a singleton) 
.SS "VeilFS::~VeilFS ()"

.SH "Member Function Documentation"
.PP 
.SS "int VeilFS::access (const char *path, intmask)"

.PP
\fIaccess\fP FUSE callback\&. Not implemented yet\&. 
.SS "int VeilFS::chmod (const char *path, mode_tmode)"

.PP
\fIchmod\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::chown (const char *path, uid_tuid, gid_tgid)"

.PP
\fIchown\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::flush (const char *path, struct fuse_file_info *fileInfo)"

.PP
\fIflush\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::fsync (const char *path, intdatasync, struct fuse_file_info *fi)"

.PP
\fIfsync\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::fsyncdir (const char *path, intdatasync, struct fuse_file_info *fileInfo)"

.PP
\fIfsyncdir\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::getattr (const char *path, struct stat *statbuf)"

.PP
\fIgetattr\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP
\fBTodo\fP
.RS 4
We have to set uid based on usename received from cluster\&. Currently not supported by cluster\&. 
.RE
.PP
.PP
\fBTodo\fP
.RS 4
same as above 
.RE
.PP

.SS "\fBJobScheduler\fP * VeilFS::getScheduler ()\fC [static]\fP"

.PP
Returns \fBJobScheduler\fP assigned to this object\&. 
.SS "int VeilFS::getxattr (const char *path, const char *name, char *value, size_tsize)"

.PP
\fIgetxattr\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::init (struct fuse_conn_info *conn)"

.PP
\fIinit\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "\fBVeilFS\fP * VeilFS::instance ()\fC [static]\fP"

.PP
Returns instance of \fBVeilFS\fP singleton\&. 
.SS "int VeilFS::link (const char *path, const char *newpath)"

.PP
\fIlink\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::listxattr (const char *path, char *list, size_tsize)"

.PP
\fIlistxattr\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::mkdir (const char *path, mode_tmode)"

.PP
mkdir FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::mknod (const char *path, mode_tmode, dev_tdev)"

.PP
\fImknod\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::open (const char *path, struct fuse_file_info *fileInfo)"

.PP
\fIopen\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::opendir (const char *path, struct fuse_file_info *fileInfo)"

.PP
\fIopendir\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::read (const char *path, char *buf, size_tsize, off_toffset, struct fuse_file_info *fileInfo)"

.PP
\fIread\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::readdir (const char *path, void *buf, fuse_fill_dir_tfiller, off_toffset, struct fuse_file_info *fileInfo)"

.PP
\fIreaddir\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::readlink (const char *path, char *link, size_tsize)"

.PP
\fIreadlink\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::release (const char *path, struct fuse_file_info *fileInfo)"

.PP
\fIrelease\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP
\fBTodo\fP
.RS 4
If TASK_SEND_FILE_NOT_USED is scheduled,file mapping has to be removed too\&. I'm not 100% sure that any of this is needed\&. 
.RE
.PP

.SS "int VeilFS::releasedir (const char *path, struct fuse_file_info *fileInfo)"

.PP
\fIreleasedir\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::removexattr (const char *path, const char *name)"

.PP
\fIremovexattr\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::rename (const char *path, const char *newpath)"

.PP
\fIrename\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::rmdir (const char *path)"

.PP
\fIrmdir\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "void VeilFS::set_rootdir (const char *path)"

.PP
Sets root dir for \fBVeilFS\fP\&. 
.SS "int VeilFS::setxattr (const char *path, const char *name, const char *value, size_tsize, intflags)"

.PP
\fIsetxattr\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::statfs (const char *path, struct statvfs *statInfo)"

.PP
\fIstatfs\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::symlink (const char *path, const char *link)"

.PP
\fIsymlink\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::translateError (stringverr)\fC [static]\fP"

.PP
errno translator\&. Translates internal VeilCLient error codes (strings) to POSIX error codes\&. If given string is not valid, EIO is returned\&. 
.PP
\fBParameters:\fP
.RS 4
\fIverr\fP literal name of POSIX error code 
.RE
.PP
\fBReturns:\fP
.RS 4
POSIX error code multiplied by -1 
.RE
.PP

.SS "int VeilFS::truncate (const char *path, off_tnewSize)"

.PP
\fItruncate\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::unlink (const char *path)"

.PP
\fIunlink\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::utime (const char *path, struct utimbuf *ubuf)"

.PP
\fIutime\fP FUSE callback\&. Not implemented yet\&.
.PP
\fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SS "int VeilFS::write (const char *path, const char *buf, size_tsize, off_toffset, struct fuse_file_info *fileInfo)"

.PP
\fIwrite\fP FUSE callback\&. \fBSee Also:\fP
.RS 4
http://fuse.sourceforge.net/doxygen/structfuse__operations.html 
.RE
.PP

.SH "Member Data Documentation"
.PP 
.SS "\fBFslogicProxy\fP* VeilFS::m_fslogic\fC [private]\fP"

.PP
\fBFslogicProxy\fP instance\&. 
.SS "\fBVeilFS\fP * VeilFS::m_instance = NULL\fC [static]\fP, \fC [private]\fP"

.PP
Class instance\&. 
.SS "\fBJobScheduler\fP* VeilFS::m_jobScheduler\fC [private]\fP"

.PP
\fBJobScheduler\fP instance\&. 
.SS "\fBMetaCache\fP* VeilFS::m_metaCache\fC [private]\fP"

.PP
\fBMetaCache\fP instance\&. 
.SS "const char* VeilFS::m_root\fC [private]\fP"

.PP
Filesystem root directory\&. 
.SS "\fBStorageMapper\fP* VeilFS::m_storageMapper\fC [private]\fP"

.PP
\fBStorageMapper\fP instance\&. 

.SH "Author"
.PP 
Generated automatically by Doxygen for VeilClient from the source code\&.
